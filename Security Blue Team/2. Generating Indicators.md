# Indicators of Compromise (IoC)

Indicators of Compromise, also referred to as IOCs are **a method of information sharing, so that organisations can determine whether they have come into contact with similar attacks.** These are some examples of common IOCs:

- **IP Addresses –** If an IP is behaving maliciously, it can be considered an IOC. **Example**: If Organisation A is suffering from a distributed denial-of service attack by 5 IPs, they could tell Organisation B to look out for the 5 IPs that are attacking them, and they are now considered indicators of compromise. This means Org B can setup alerts for these IPs, so if they attempt to do the same thing they can immediately block them if needed.

- **Email Addresses –** If an email address is sending out malicious emails, it can be considered an IOC. **Example:** Organisation A is targeted by a phishing campaign from the email address _purelyanexample@googlemail.com_. Org A can share this with other organisations, and tell them to be on the lookout for emails coming from this sender.

- **File Sizes Value –** It’s pretty unlikely that a large number of files will have the exact same number of bytes. If we have a piece of malware, we can see the file size, and use this as an indicator to then search through all files, looking for ones that match.

- **MD5/SHA-1 Hashes –** Hashing is a one-way cryptographic function that allows us to create a signature represented by a string value, known as a checksum. If the file is modified in any way, the hash value will be completely different. So if we have two identical files on a system, and we know the hash of one, we can find the other using this value as an IOC.

- **Strings –** We can retrieve strings from a file, and use them as an IOC for searching. In the below example, I have used the command `**strings**` on a random .exe file, which will output all human-readable strings to the terminal. When selecting an appropriate strings IOC we want something that is not common, otherwise we will detect too many false positives when searching. An example would be a piece of malware that contains the string “0wNeD BY #Lun4rSqUAD”, in this case we would use “Lun4rSqUAD” as a string-based IOC, as it is extremely unique.

## **Retrieving File Size Property**

There are two ways we can get a file’s size; using the GUI, or using the command-line. To do it within Kali you can simply navigate to the directory where the file is stored, find the file and: **right-click > properties > size value**.

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/1b529039fb612a337702cf81427a8edeb1103811bb3c7f54a259acef22c247aa4e995393972d255010e63df06933.png)

To find a file’s size via the linux command-line we will navigate to the directory where the file is, and use the command `ls -lh` which will list all files and their sizes. In this case after “root root” we see the number “349”, which represents 349 bytes, the same value as shown above via the file properties tab.

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/082a960b2fea72b08aac0cad2ba4dca662e281d249c54166ff57f49a5be1b37e7be836de8648ef695d90ce0f3be9.png)

Let's cover how to do this on Windows with another files. We can simply right-click the file and go to Properties:

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/140ecf22561cf849420c21bdfbac0c09e3fdc744c4bbe28ef1b8ac6ae9b7405ce88be6ffaede2c9638c747d9b45a.PNG)

## **Retrieving File Name Property**

This is the easiest IOC to collect, as we can simply read the file’s name below the icon, view it via the properties pane (**right-click > properties > Name value**), or by listing the contents of the file’s directory.

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/76539b77dd80ca1487818c5e1a83da12515877182fa9863f75b9a2dcf9dbccd0cde6d0cc48b9d400be041cac27ee.png)

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/ef868a3b739efebaab70526992744a928d26e77e64fb49abf203ccb751dddb4e3f27c927744e539b48dd6f321b25.png)

This is the same for files on a Windows-based system, where we will right-click it, go to Properties, and copy the filename:

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/7fbcfedacd9b0eedc789ef68b2a1ebe81588ef86fc8ceed2431d3e43e46e42984bd4066690a2a3f51987b2fa9d9b.PNG)

Great! These are some pretty basic indicators, but they are still useful regardless. We'll explore two other indicators next, called ‘hashes’ and ‘strings’.

# Generating File Hash indicators

**But first, what are hashes?** #hash #hashes

A hash is a unique string value that corresponds to the contents of the file. They are generated by hashing algorithms, such as Message Digest 5 (MD5) or Secure Hash Algorithm 256 (SHA256). If two files are exactly the same, the hash will match. But if even one character is different, the files will have unique hash values (we'll show you this in a second!).

## **Generating a MD5 Checksum**
#md5 #checksum #hash
In the below example we create a md5 checksum of the file **TextFile2.txt** on a Linux-based system using the command `md5sum TextFile2.txt`, giving us the hash **5d363d305385b3a71ca7eed28eb2c209**.

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/be32fbb5eaacb14c37255d4af5ae4fe310616f5ed326de2d6a255a384a2c2d64896ffb8c134e97801aaf1c3f8beb.png)

Then we edit the file and change the first line, adding another “!” to the end. After generating a hash value, we can see the value is now completely different!

- Previously: **5d363d305385b3a71ca7eed28eb2c209**
- Now: **584cce49f570c0e4578d22e431e5e4aa**

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/468745f15274a44a883ec3567fb2c232fb5a33099fa7535810804fc5c9296ef8e585e3cc1c5249daabf41cace084.png)

We use the same command to use other hashing algorithms, such as the industry standard, SHA256. Simply replace the command md5sum with 

```bash
sha256sum filename
```

It's worth noting that MD5 hashes are not as commonly used nowadays due to the chance for hash collisions, meaning two files _could_ provide the same hash.

#Get-FileHash
Now let's go over how to retrieve file hashes in Windows! Open a PowerShell terminal, move into the same location as the file you want to retrieve the hash for, and use the command `**Get-FileHash <filename>**`. By default, the hashing algorithm will be SHA256. But we can use the `**-algorithm**` flag to specify what algorithm we want to use, such as MD5 or SHA1.

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/5cecdcedf5cfca556e54385b455f987e1b02ddc735ef37a1fd56bc94019ed46c080df5f08aca99256bc8d8fcf52d.PNG)

#certutil 
Windows also has `certutil`, isn't recommended to be used in any production code and doesn't provide any guarantees of live site support or application compatibilities. It's a tool utilized by developers and IT administrators to view certificate content information on devices.

Supports - MD2, MD4, MD5, SHA1, SHA256, SHA384, SHA512.

```bash
certUtil -hashfile pathToFileToCheck MD5
certUtil -hashfile pathToFileToCheck SHA256
```

Note that the hash algorithms are case-sensitive. Be sure to type, for example, “MD5”, not “md5”


# Mandiant IOC Generator
#mandiant #ioc #ioc_generator
Mandiant IOC Editor is a “free tool that provides an interface for managing data and manipulating the logical structures of IOCs”. FireEye, a threat intelligence company, has provided this tool for free to the public, and it’s a great piece of software to learn about creating IOCs, which are essentially XML files that can “capture diverse information about threats, including attributes of malicious files, characteristics of registry changes and artifacts in memory”. Mandiant IOCe is only designed for Windows OS, so you’ll either need to [download a free Windows 10 disk image](https://developer.microsoft.com/en-us/windows/downloads/virtual-machines) or use your host if you run Windows (we won’t be handling real malware yet so you’re safe!).

Essentially, we use IOC Editor to combine different values and export it as an IOC file, which we will use later to hunt for malware. Please pay attention to the following complete walkthrough, so you are able to use this tool in the next activity. You can view the tool page for Mandiant IOC Editor [here](https://fireeye.market/apps/S7cWpi9W) – which provides information on the features and allows you to [download](https://fireeye.market/apps/S7cWpi9W) it.

## **Follow This Walkthrough**

We strongly suggest that you follow this lesson in order to fully understand how to use the methods and tools covered below. Alternatively, you can just read what we did, and apply it to the activity in the next lesson.

## **Installation**

Download the .zip archive from FireEye’s website, extract it, and run the .msi file to install IOCe. Once it has finished, launch the program, and you should see the below popup. Don’t click anything just yet. We need to create a folder where we will export our IOC files to. Go anywhere you want, and create a folder called IOCs. In this example i’ll be placing the folder in the following location **Desktop > Intro 2 Threat Hunting > IOCs**. If you closed the above popup, simply go to **File > Open IOC Directory** within IOCe. Select your newly-created folder, and you’re good to go! You should see the file path at the top of the window.

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/28e047e0435d536d737273ac4beb301cc2a6e5eb33d47b0f0d94b30b69a7f9c6bd883b5cfc07891b8c209a202afb.png)

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/5faceec828bf4b7efb9f074655d897d161f41896544bdb45bc5703d3bd7c51de0cca8188e8d4548387912b74224d.png)

## **Creating an IOC File**

Navigate to **File > New > Indicator** so we can start to create our first IOC file. Once created, click on the entry and you should see the following display:

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/d04478aa7f72aad15fd4f9d28320aa94fae6e0ad5f48029d90ec5024ea7ae76b86e30f2d48837660b5ef677510ad.png)

We have everything ready to start populating our IOC file and create a useful resource for either threat intelligence or threat hunting. In the below screenshot you can see that I’ve edited the Name, Author, and Description fields of our IOC.

  
![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/1286c828672063491619145857fd14270f5b51aa8249de03ed6b031db7adb22518df4b0cc5ac58d9ec10a6508b77.png)

## **Populating an IOC File**

The next task is for us to populate this entry with some values so that it actually means something. As covered in the last lesson, for this example we’ll be using an MD5 hash, a SHA-1 hash, the file name, and file size. So first lets go gather those IOCs from our example file. We will be using malware at a later stage, but for now we’ll use a simple image file, so you can get comfortable with collecting IOCs. **Want to follow along with this example? Download the same file** [**here**](https://unsplash.com/photos/dYEuFB8KQJk)**!**

We have the file in our Downloads directory, and using the ls -lh command we can see that the file is 1.1MiB in size. It’s important to note that this isn’t an exact size, as this command rounds-up the value. So to find the true value, we need to go to the file in the GUI **right-click > properties > Size** where we can see it is actually 1,057,889 bytes. We now have our size IOC value! We can also grab the file name whilst we’re here (_because i’m not typing that out manually_ !). Copy and paste the full name (including extension) from the properties pane and make a note of it.

- **File Size Value = 1057889**
- **File Name Value = clint-patterson-dYEuFB8KQJk-unsplash.jpg**

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/854e5f3b41d7ab23e04b0ab25d5512a81bc0afb881591aa4adee705877fcb8e600af3f4ef2c387ad25a5cfcbee48.png)

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/c15e5eac7b27c91a1237173284f6ab5f6b2b1c7a847007afe908b777c25606495676090502b89c67e9fad8e55695.png)

Next let’s grab the MD5 and SHA-1 hashes for this file. Use the `**md5sum**` and `**sha1sum**` commands on the file to collect the values. Using these commands, we’ll retrieve the following:

- **MD5 Hash = 81ef348226632fb1061d22d4e6fd3479**
- **SHA-1 Hash = 173b0434341b25fb17c4b2829f8058b29738faef**

  
![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/642d1cfa2200c25b656c759ff060e9ca643d4906214f7b06bf600310c58f2ad181a80a24f69373cd649ed8f73b90.png)![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/9502f0fa53f62e76b0c158a238b5d7f2c75d89135765803dc809676cc484744bb969bbe4523ca00bd844c3a8acd6.png)

That’s enough for this example. Head back over to IOCe so we can start adding the values to our IOC file! Right-click anywhere in the bottom pane and go to **Add Item > FileItem > File MD5**.

  
![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/d998219ab1a2655b205010ca1ad6264956e79682f6c08a8c4276dccbb0d08218940a9e4df65ecd5494d56f82704a.png)

This will create a new entry in our OR tree. Anything in this pane will be searched for when we use IOC files later for hunting. There’s a major difference between the two possible groups, OR + AND:

- **AND –** If we have three IOCs in this tree, all three have to match a file to get a positive hit. If only 2 IOCs are present, it will not notify us.
- **OR –** If we have three IOCs in this tree, if any of them are present in a file, then we will get a notification later when using Redline.

Let’s add the rest of the fields we need to our IOC file:

- SHA-1 Hash: **Add Item > FileItem > Sha1sum**
- File Name: **Add Item > FileItem > File Name**
- File Size: **Add Item > FileItem > File Size**

Once you have all of these ready, your display should look something similar to this:

![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/1fc74ba375122c85dc7585ac320bd7532ea3f5381f43e2d544c292021186d97de2cb76b75a5a519760fc40f919e7.png)

Fill out the fields with the values we gathered earlier by double-clicking on them. Once you’re done, save the file using the button in the bottom right, and that’s it, you’ve created your first simple IOC file!

  
![](https://d2y9h8w1ydnujs.cloudfront.net/uploads/content/images/9f89edfbc9af14b88300316da9ec152e12277a41d6dfa9e96190b3898e1c4c64df276b606c2983b78440319f9db3.gif)